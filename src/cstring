///////////////////////////////////////////
//  CString.h - Gestion de chaines de    //
//              caracteres               //
///////////////////////////////////////////
//       Developpe par Soilwork          //
//               v. 0.10                 //
//       Creation : 03/08/2004           //
//     Modification : 24/08/2004         //
///////////////////////////////////////////

#ifndef CSTRING_H_INCLUDED
#define CSTRING_H_INCLUDED

#include <stdio.h>
#include <tchar.h>


//Longueur maximale utilisee pour les chaines temporaires utilisees dans  
//certaines methodes de la classe. 
//Les chaines 'normales' peuvent etre plus longues.
#define MAX_LG 1024

class CString
{
private:
    char *ptr;
    
    //Longueur de la chaine
    unsigned int len;
    
    //Indice de debut du prochain token
    unsigned int tokenIndex; //Pour decouper la chaine en tokens...
    
    inline void reallocation(int lg);
public:
    ///////////////////        
    // Constructeurs //
    ///////////////////
    
    //Constructeur par défaut
    CString(){ptr=new char[1];ptr[0]=0; tokenIndex=0; len=0;}
    //Constructeur par recopie
    CString(const CString& string);
    //Constructeur à partir d'une chaîne de caracteres (char *)
    CString(const char *pointer);
    //Constructeurs à partir de nombres entiers/flottants/doubles
    CString(int number);
    CString(float number);
    CString(double number);
    //A partir d'un caractère
    CString(char character);
    //A partir d'un booleen ==> Contient true ou false.
    CString(bool boolean);
    //Construction d'une chaine contenant n fois le caractere character
    CString(int n, char character);
    
    //Destructeur!
    ~CString(){ if(ptr) delete[]ptr;}
    
    ////////////////
    // Accesseurs //
    ////////////////
    void setPtr(const char *pointer) {(*this)=pointer;}
    char * getPtr() const {return ptr;}
    
    //Désactivé à cause de l'opérateur de cast en char * ==> Ambiguite!
    //char operator[](unsigned int index) const;
    
    //Retourne le caractère à l'indice donné, -1 en cas de mauvais indice
    //(Equivalent a l'operateur [])
    char charAt(unsigned int index) const;
    
    //Longueur de la chaine
    int length() const {return len;} //{return strlen(ptr);}
    
    //Operateurs de conversion
    operator const char*() const {return (const char *)ptr;}
    
    
    //////////////////////////////
    // Operateurs d'affectation //
    //////////////////////////////
    //Ces operateurs retournent une reference sur la chaine elle-meme.
    CString &operator=(const CString& string);
    CString &operator=(const char *pointer);
    CString &operator=(int number);
    CString &operator=(float number);
    CString &operator=(double number);
    CString &operator=(char character);
    CString &operator=(bool boolean);
    
    //Méthodes d'affectation
    CString &assign(CString string);
    CString &assign(int n, char character);
    
    //Lecture d'une ligne au clavier...
    CString &getLine();
    
    //Nettoyage de la chaine... (retour a une chaine vide)
    CString &clear();
    
    ///////////////////////////////
    // Operateurs de comparaison //
    ///////////////////////////////
    //Methodes de comparaison QUI PRENNENT EN COMPTE LA CASSE
    //(majuscule/minuscule)
    bool operator==(const CString& string) const;
    bool operator!=(const CString& string) const;
    bool operator<(const CString& string) const;
    bool operator<=(const CString& string) const;
    bool operator>(const CString& string) const;
    bool operator>=(const CString& string) const;
    
    //Methode de comparaison identique a ==
    bool equals(const CString& string) const;
    
    //Equals qui ignore la casse
    bool equalsIgnoreCase(const CString& string) const;
    
    /////////////////////////////////
    // Opérateurs de concatenation //
    /////////////////////////////////
    CString &operator+=(const CString& string);
    
    //Pour pouvoir ajouter tout et n'importe quoi :)
    friend CString operator+(CString first, CString second);
    
    //Methodes de concatenation...
    CString &append(CString string);
    CString &append(int n, char character);
    
    //Et aussi d'insertion...
    CString &insertAt(int index, CString string);
    
    //////////////////////
    // Autres fonctions //
    //////////////////////
    //Est-ce que la chaine commence par prefix?
    bool startsWith(CString prefix) const;
    //Est-ce que la chaine se termine par suffix?
    bool endsWith(CString suffix) const;
    
    //Est-ce que la région de la chaine commencant a l'indice toffset
    //et de longueur len est identique à la region de other commencant
    //a ooffset et de meme longueur len (avec ou sans gestion de la casse)
    bool regionMatches(int toffset, CString other, int ooffset, int len,
                       bool ignoreCase=false) const;
    
    //Extraction de sous-chaine commencant a l'indice index jusqu'a la fin
    CString substring(int index) const;
    //Idem, mais sous-chaine de longueur length
    CString substring(int index, int length) const;
    
    //Indice de la premiere occurence de substring dans la chaine
    //-1 si non trouvé
    int indexOf(CString substring) const;
    //Idem, mais pour la derniere occurence de substring
    int lastIndexOf(CString substring) const;
    
    //Retourne la chaine || eniahc al enruoter // :P
    CString &reverse();
    
    ////////////////////////////
    //   Methodes isMachin()  //
    ////////////////////////////
    //Est-ce que la chaine est vide?
    bool isEmpty() const {return(length()==0?true:false);}
    
    //Pour les fonctions suivantes, le paramètre indique l'indice du char a
    //tester ou bien la chaine complete s'il vaut la valeur par defaut -1
    
    //Est-ce que la chaine est composée de caracteres alphanumériques?
    bool isAlpha(int index=-1) const;
    //Caracteres numeriques
    bool isNum(int index=-1) const;
    //Les chiffres et les lettres!
    bool isAlNum(int index=-1) const;
    //Chaine "blanche"
    bool isSpace(int index=-1) const;
    //Casse des caractères
    bool isLower(int index=-1) const;
    bool isUpper(int index=-1) const;
    
    //Pour savoir si on peut convertir une chaine en nombre...
    bool isInteger() const;
    bool isFloat() const;
    
    //Fonction inutile pour savoir si une chaine est un palindrome ^_^
    bool isPalindrome() const;
    
    //Remplace toutes les occurences de string par byString
    //Retourne le nombre de changements effectues
    int replace(CString string, CString byString);
    //Remplace uniquement le premier
    int replaceFirst(CString string, CString byString);
    //Uniquement le dernier
    int replaceLast(CString string, CString byString);
    //Remplace la sous-chaine de longueur lg1 commencant a l'indice index
    //par byString.
    int replaceAt(int index, int lg1, CString byString);
    
    //Pour changer la casse de la chaine...
    CString &toLowerCase(); //En minuscules
    CString &toUpperCase(); //En majuscules
    //Premiere lettre de chaque mot en majuscules, le reste en minuscules.
    //Les mots sont séparés par tout caractere non-alphabétique.
    CString &capitalize();
    
    //Fonction "a la printf"
    CString &Format(char *formatString, ...);
    
    //Redimensionne la chaine, en ajoutant character a la fin si necessaire
    //(len n'inclut pas l'\0 final!)
    CString &resize(int len, char character=' ');
    
    //Suppression d'espaces superflus
    CString &ltrim();
    CString &rtrim();
    CString &trim(); //Des deux cotes
    
    //Fonction de hachage facon java.lang.String (cf Java API)
    unsigned long hashCode() const;
    
    //Decoupage de la chaine... 
    //retourne un pointeur vers des chaines et 
    //le nombre de morceaux dans la variable par reference outNumber.
    CString *split(int &outNumber, char character) const;
    
    //Tokenisation : Les tokens sont separes par des espaces
    //OU compris entre simple ou double quotes.
    int countToken() const;
    void resetToken(){tokenIndex=0;}
    CString nextToken();
    CString endOfString() const;
};

#endif
